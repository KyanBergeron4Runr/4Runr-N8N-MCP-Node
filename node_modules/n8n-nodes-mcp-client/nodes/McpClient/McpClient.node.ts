// n8n types are resolved at runtime in the n8n environment
import type { INodeType, INodeTypeDescription, INodeExecutionData, IExecuteFunctions } from 'n8n-workflow';
import type { NodeOperationError } from 'n8n-workflow';
// Use require for EventSource for compatibility
const EventSource = require('eventsource');

interface ToolParameter {
	type: string;
	description: string;
	required?: boolean;
	default?: any;
}

interface ToolDefinition {
	name: string;
	description: string;
	parameters: { [key: string]: ToolParameter };
}

export class McpClient implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'McpClient',
		name: 'mcpClient',
		group: ['input'],
		version: 1,
		description: 'Streams tools from an MCP server via SSE',
		defaults: {
			name: 'McpClient',
			color: '#00b894',
		},
		inputs: [],
		outputs: ['main'],
		icon: 'fa:plug',
		isTool: true,
		usableAsTool: true,
		credentials: [],
		properties: [
			{
				displayName: 'SSE URL',
				name: 'sseUrl',
				type: 'string',
				default: '',
				description: 'The URL of the MCP SSE endpoint (e.g., http://localhost:3000/mcp-events)',
				required: true,
			},
		],
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const sseUrl = this.getNodeParameter('sseUrl', 0) as string;
		console.log(`[McpClient] Connecting to SSE: ${sseUrl}`);

		return new Promise((resolve, reject) => {
			const eventSource = new EventSource(sseUrl);

			eventSource.onopen = () => {
				console.log('[McpClient] SSE connection opened');
			};

			eventSource.onerror = (err: unknown) => {
				console.error('[McpClient] SSE connection error', err);
				eventSource.close();
				// @ts-ignore: NodeOperationError will resolve in n8n runtime
				reject(new NodeOperationError(this.getNode(), 'Failed to connect to SSE endpoint'));
			};

			eventSource.addEventListener('tools', (event: MessageEvent) => {
				console.log('[McpClient] Received tools event:', event.data);
				try {
					const parsed = JSON.parse(event.data);
					if (parsed.tools && Array.isArray(parsed.tools)) {
						const tools: ToolDefinition[] = parsed.tools.map((tool: any) => ({
							name: tool.name,
							description: tool.description,
							parameters: tool.parameters || {},
						}));
						console.log(`[McpClient] Emitting ${tools.length} tools`);
						eventSource.close();
						resolve([this.helpers.returnJsonArray(tools)]);
					} else {
						console.warn('[McpClient] No tools array in event data');
					}
				} catch (err) {
					console.error('[McpClient] Failed to parse tools event', err);
				}
			});

			// Ignore all other event types (e.g., ping)
		});
	}
} 